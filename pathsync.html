<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PathSync: Timeline Proximity Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .spinner {
            border-top-color: #4f46e5; /* indigo-600 */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Style for date input */
        input[type="date"]::-webkit-calendar-picker-indicator {
            cursor: pointer;
        }

        /* --- Page Load Animation --- */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .content-fade-in {
            animation: fadeIn 0.5s ease-in-out forwards;
        }

        /* --- Sidebar Link Hover --- */
        aside nav a {
            transition: all 0.2s ease-in-out;
        }
        aside nav a:hover {
            transform: translateX(4px);
            color: #312e81; /* indigo-900 */
        }

        /* --- Card Hover Animation --- */
        .animated-card {
            transition: all 0.2s ease-in-out;
        }
        .animated-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.07), 0 4px 6px -4px rgb(0 0 0 / 0.07);
        }
    </style>
</head>
<body class="flex min-h-screen bg-gray-100 text-slate-700">

    <aside class="w-64 flex-shrink-0 border-r border-gray-200 bg-white flex flex-col p-6 sticky top-0 h-screen">
        <a href="index.html" class="text-2xl font-bold text-slate-900 hover:text-indigo-600 transition-colors mb-8">Aiden</a>
        <nav class="flex flex-col space-y-3">
            <a href="index.html" class="text-lg font-medium text-slate-500 hover:text-slate-900 transition-colors">Projects</a>
            <a href="notes.html" class="text-lg font-medium text-slate-500 hover:text-slate-900 transition-colors">Notes</a>
            <a href="about.html" class="text-lg font-medium text-slate-500 hover:text-slate-900 transition-colors">About</a>
        </nav>
        <div class="mt-auto"> <a href="https://github.com/Aiden-korbs" target="_blank" class="text-slate-400 hover:text-slate-600 transition-colors">
                <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M12 2C6.477 2 2 6.477 2 12c0 4.418 2.865 8.168 6.839 9.492.5.092.682-.217.682-.482 0-.237-.009-.868-.014-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.031-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.378.203 2.398.1 2.651.64.7 1.03 1.595 1.03 2.688 0 3.848-2.338 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.001 10.001 0 0022 12c0-5.523-4.477-10-10-10z" clip-rule="evenodd" /></svg>
            </a>
        </div>
    </aside>

    <div class="flex-grow overflow-y-auto h-screen">
        <main class="max-w-7xl mx-auto px-10 py-12 content-fade-in">
            
            <div class="lg:grid lg:grid-cols-3 lg:gap-12">
            
                <div class="lg:col-span-2 space-y-8">
                    <div class="text-center">
                        <h1 class="text-4xl font-extrabold text-slate-900">PathSync</h1>
                        <p class="text-slate-600 mt-2">Analyze Google Timeline files to find proximity events.</p>
                    </div>

                    <div class="space-y-8 pt-8 border-t border-gray-200">
                        <div>
                            <h2 class="text-lg font-semibold text-slate-800 mb-4">1. Upload Timeline Files</h2>
                            <div id="file-inputs" class="space-y-3"></div>
                            <button id="add-file-btn" class="w-full mt-3 text-sm font-medium text-indigo-600 hover:text-indigo-800 transition">+ Add Another File</button>
                        </div>
                        
                        <div>
                            <h2 class="text-lg font-semibold text-slate-800 mb-4">2. Set Filters & Thresholds</h2>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label for="start-date" class="block text-sm font-medium text-slate-600">Start Date</label>
                                    <input type="date" id="start-date" class="mt-1 block w-full bg-white border-gray-300 text-slate-800 rounded-md shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                                </div>
                                <div>
                                    <label for="end-date" class="block text-sm font-medium text-slate-600">End Date</label>
                                    <input type="date" id="end-date" class="mt-1 block w-full bg-white border-gray-300 text-slate-800 rounded-md shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                                </div>
                                <div>
                                    <label for="distance" class="block text-sm font-medium text-slate-600">Distance (meters)</label>
                                    <input type="number" id="distance" value="100" class="mt-1 block w-full bg-white border-gray-300 text-slate-800 rounded-md shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                                </div>
                                <div>
                                    <label for="time" class="block text-sm font-medium text-slate-600">Time (minutes)</label>
                                    <input type="number" id="time" value="2" class="mt-1 block w-full bg-white border-gray-300 text-slate-800 rounded-md shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm p-2">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="text-center pt-8 border-t border-gray-200">
                        <button id="run-analysis" class="w-full md:w-auto bg-indigo-600 text-white font-semibold py-3 px-8 rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 focus:ring-offset-gray-100 transition disabled:bg-gray-400">
                            Run Analysis
                        </button>
                    </div>

                    <div id="results-container" class="space-y-6 pt-8 border-t border-gray-200 hidden">
                        <h2 class="text-3xl font-bold text-center text-slate-900">Analysis Results</h2>
                        <div id="status" class="text-center text-slate-600 p-4 bg-white rounded-md border border-gray-200 shadow-sm"></div>
                        <p id="summary" class="text-center font-medium text-lg"></p>
                        <div id="closest-match-card" class="bg-white border border-gray-200 rounded-lg p-6 space-y-4 hidden shadow-sm animated-card">
                            <h3 class="text-xl font-semibold text-emerald-600">Closest Match Found</h3>
                            <div id="closest-match-details" class="space-y-3 text-sm"></div>
                        </div>
                    </div>
                </div>

                <div class="lg:col-span-1 mt-12 lg:mt-0">
                    <div class="sticky top-12">
                        <div class="bg-white p-4 rounded-lg border border-gray-200 shadow-sm animated-card">
                            <h3 class="font-semibold text-slate-800 flex items-center mb-4">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                                </svg>
                                How to Get Your Data
                            </h3>
                            <div class="text-slate-600 text-sm space-y-4 pt-4 border-t border-gray-200">
                                <div>
                                    <h4 class="font-semibold text-slate-700">Method 1: Google Takeout (Desktop)</h4>
                                    <ol class="list-decimal list-inside mt-2 space-y-1">
                                        <li>Visit the <a href="https://takeout.google.com/" target="_blank" class="text-indigo-600 hover:underline">Google Takeout</a> website.</li>
                                        <li>Click "Deselect all", then scroll and select "Location History".</li>
                                        <li>Ensure the format is JSON, then "Create export".</li>
                                    </ol>
                                </div>
                                <div>
                                    <h4 class="font-semibold text-slate-700">Method 2: Google Maps App (Mobile)</h4>
                                    <ol class="list-decimal list-inside mt-2 space-y-1">
                                        <li>Open the Google Maps app and tap your profile picture.</li>
                                        <li>Go to "Your timeline", then tap the three-dot menu (...) and select "Settings and privacy".</li>
                                        <li>Scroll to "Location settings" and tap "Download a copy of your data".</li>
                                    </ol>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <footer class="mt-12 border-t border-gray-200">
                <div class="py-8 text-center text-slate-500">
                    <p>&copy; 2025 Aiden. All Rights Reserved.</p>
                </div>
            </footer>
        </main>
    </div>

    <script>
        const fileUploadContainer = document.getElementById('file-inputs');
        const addFileBtn = document.getElementById('add-file-btn');
        const runBtn = document.getElementById('run-analysis');
        const resultsContainer = document.getElementById('results-container');
        const statusEl = document.getElementById('status');
        const summaryEl = document.getElementById('summary');
        const closestMatchCard = document.getElementById('closest-match-card');
        const closestMatchDetails = document.getElementById('closest-match-details');
        let fileInputCounter = 0;

        function createFileInput() {
            fileInputCounter++;
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-center space-x-2';
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.id = `file-input-${fileInputCounter}`;
            input.className = 'hidden';
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.className = 'cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-medium py-2 px-4 rounded-md shadow-sm transition';
            label.textContent = 'Choose File';

            const fileNameSpan = document.createElement('span');
            fileNameSpan.className = 'text-slate-500 text-sm truncate';
            fileNameSpan.textContent = 'No file chosen...';

            input.addEventListener('change', () => {
                fileNameSpan.textContent = input.files.length > 0 ? input.files[0].name : 'No file chosen...';
            });
            wrapper.append(input, label, fileNameSpan);
            fileUploadContainer.appendChild(wrapper);
        }
        
        createFileInput();
        createFileInput();
        addFileBtn.addEventListener('click', createFileInput);

        runBtn.addEventListener('click', async () => {
            runBtn.disabled = true;
            runBtn.innerHTML = `<div class="spinner w-5 h-5 border-4 rounded-full inline-block"></div> Analyzing...`;
            resultsContainer.classList.remove('hidden');
            statusEl.textContent = 'Starting analysis...';
            summaryEl.textContent = '';
            closestMatchCard.classList.add('hidden');
            
            const files = Array.from(document.querySelectorAll('input[type="file"]'))
                .filter(input => input.files.length > 0).map(input => input.files[0]);

            if (files.length < 2) {
                statusEl.textContent = 'Error: Please select at least two files.';
                runBtn.disabled = false;
                runBtn.textContent = 'Run Analysis';
                return;
            }
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;

            let processedData = {};
            for (const file of files) {
                statusEl.textContent = `Parsing ${file.name}...`;
                try {
                    const jsonData = JSON.parse(await file.text());
                    const events = parseTimelineData(jsonData, startDate, endDate);
                    if (events.length > 0) {
                        processedData[file.name] = events;
                    } else {
                        statusEl.textContent += ` (Warning: No valid events found in the selected date range).`;
                    }
                } catch (error) {
                    statusEl.textContent = `Error processing ${file.name}: ${error.message}`;
                    runBtn.disabled = false;
                    runBtn.textContent = 'Run Analysis';
                    return;
                }
            }
            
            statusEl.textContent = 'Comparing timelines...';
            const fileKeys = Object.keys(processedData);
            let totalMatches = 0;
            let overallClosestMatch = null;
            
            for (let i = 0; i < fileKeys.length; i++) {
                for (let j = i + 1; j < fileKeys.length; j++) {
                    const [file1, file2] = [fileKeys[i], fileKeys[j]];
                    const [data1, data2] = [processedData[file1], processedData[file2]];
                    const distanceKm = parseFloat(document.getElementById('distance').value) / 1000;
                    const timeMins = parseInt(document.getElementById('time').value);
                    const matches = compareTimelines(data1, data2, timeMins, distanceKm);
                    if (matches.length > 0) {
                        totalMatches += matches.length;
                        const closest = findClosestMatch(matches);
                        if (!overallClosestMatch || closest.distance_km < overallClosestMatch.distance_km) {
                            overallClosestMatch = closest;
                            overallClosestMatch.files = [file1, file2];
                        }
                    }
                }
            }

            summaryEl.textContent = `Analysis complete. Found ${totalMatches} matches.`;
            if (overallClosestMatch) {
                statusEl.textContent = 'Looking up location...';
                const locationName = await getLocationName(overallClosestMatch.event1.latitude, overallClosestMatch.event1.longitude);
                displayClosestMatch(overallClosestMatch, locationName);
            } else {
                statusEl.textContent = 'No matches found within the specified thresholds.';
            }

            runBtn.disabled = false;
            runBtn.textContent = 'Run Analysis';
        });

        function displayClosestMatch(match, locationName) {
            closestMatchCard.classList.remove('hidden');
            const [file1, file2] = match.files;
            const { event1, event2, distance_km, time_difference } = match;
            const event1UTC = moment.utc(event1.timestamp).format('YYYY-MM-DD HH:mm:ss');
            const event2UTC = moment.utc(event2.timestamp).format('YYYY-MM-DD HH:mm:ss');

            closestMatchDetails.innerHTML = `
                <p><strong>Files:</strong> ${file1} & ${file2}</p>
                <p><strong>Location:</strong> ${locationName}</p>
                <p><strong>Distance:</strong> ${(distance_km * 1000).toFixed(2)} meters</p>
                <p><strong>Time Difference:</strong> ${time_difference.toFixed(2)} seconds</p>
                <div class="pt-2 mt-2 border-t border-gray-200">
                    <p class="font-semibold text-amber-600">${file1}:</p>
                    <p class="pl-2">Lat: ${event1.latitude}, Lon: ${event1.longitude}</p>
                    <p class="pl-2">Timestamp (UTC): ${event1UTC}</p>
                </div>
                <div class="pt-2 mt-2 border-t border-gray-200">
                    <p class="font-semibold text-rose-600">${file2}:</p>
                    <p class="pl-2">Lat: ${event2.latitude}, Lon: ${event2.longitude}</p>
                    <p class="pl-2">Timestamp (UTC): ${event2UTC}</p>
                </div>`;
            statusEl.textContent = 'Closest match details displayed below.';
        }
        
        function parseTimelineData(jsonData, startDateStr, endDateStr) {
            let events = [];
            const startDate = startDateStr ? new Date(startDateStr + 'T00:00:00Z').getTime() : null;
            const endDate = endDateStr ? new Date(endDateStr + 'T23:59:59Z').getTime() : null;

            const eventInRange = (timestamp) => {
                if (startDate && timestamp < startDate) return false;
                if (endDate && timestamp > endDate) return false;
                return true;
            };

            if (jsonData.semanticSegments) {
                jsonData.semanticSegments.forEach(segment => {
                    const processPoint = (time, locationString) => {
                        const timestamp = new Date(time).getTime();
                        if (eventInRange(timestamp) && typeof locationString === 'string') {
                            const coords = locationString.match(/[-+]?\d+\.\d+/g);
                            if (coords && coords.length === 2) events.push({timestamp, latitude: parseFloat(coords[0]), longitude: parseFloat(coords[1])});
                        }
                    };

                    if (segment.timelinePath) {
                        segment.timelinePath.forEach(point => processPoint(point.time, point.point));
                    } else if (segment.visit) {
                        processPoint(segment.startTime, segment.visit?.topCandidate?.placeLocation);
                    }
                });
            }
            else if (Array.isArray(jsonData)) {
                jsonData.forEach(item => {
                    const timestamp = new Date(item.startTime).getTime();
                    if (eventInRange(timestamp)) {
                         const locStr = item.visit?.topCandidate?.placeLocation;
                         if (locStr && typeof locStr === 'string') {
                            const coords = locStr.match(/[-+]?\d+\.\d+/g);
                            if (coords && coords.length === 2) events.push({timestamp, latitude: parseFloat(coords[0]), longitude: parseFloat(coords[1])});
                        }
                    }
                });
            }
            else if (jsonData.locations) {
                jsonData.locations.forEach(loc => {
                    const timestamp = new Date(loc.timestamp).getTime();
                    if (eventInRange(timestamp) && loc.latitudeE7 && loc.longitudeE7) {
                        events.push({timestamp, latitude: loc.latitudeE7 / 1e7, longitude: loc.longitudeE7 / 1e7});
                    }
                });
            }
            return events.sort((a, b) => a.timestamp - b.timestamp);
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; const toRad = x => x * Math.PI / 180;
            const dLat = toRad(lat2 - lat1); const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2)**2;
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        function compareTimelines(data1, data2, timeMins, distanceKm) {
            const matches = []; const timeMs = timeMins * 60 * 1000;
            let i = 0, j = 0;
            while (i < data1.length && j < data2.length) {
                const timeDiff = data1[i].timestamp - data2[j].timestamp;
                if (timeDiff > timeMs) { j++; continue; }
                if (timeDiff < -timeMs) { i++; continue; }
                let k = j;
                while (k < data2.length) {
                    const subTimeDiff = Math.abs(data1[i].timestamp - data2[k].timestamp);
                    if (subTimeDiff > timeMs) break;
                    const distance = haversineDistance(data1[i].latitude, data1[i].longitude, data2[k].latitude, data2[k].longitude);
                    if (distance <= distanceKm) matches.push({event1: data1[i], event2: data2[k], time_difference: subTimeDiff / 1000, distance_km: distance});
                    k++;
                }
                i++;
            }
            return matches;
        }

        function findClosestMatch(matches) {
            return !matches || matches.length === 0 ? null : matches.reduce((a, b) => b.distance_km < a.distance_km ? b : a);
        }
        
        async function getLocationName(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                if (!response.ok) throw new Error(`API failed: ${response.status}`);
                const data = await response.json();
                return data.display_name || "Unknown Location";
            } catch (error) {
                console.error("Geocoding error:", error);
                return "Could not fetch location name.";
            }
        }
    </script>
</body>
</html>