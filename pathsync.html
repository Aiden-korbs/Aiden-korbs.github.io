<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PathSync: See where you crossed paths</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
        }
        .spinner {
            border-top-color: #f43f5e; /* rose-500 */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Style for date input placeholder */
        input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(0.8);
        }
    </style>
</head>
<body class="text-gray-200 min-h-screen">

    <!-- Header -->
    <header class="border-b border-gray-700/50 sticky top-0 bg-gray-900/80 backdrop-blur-sm z-10">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <a href="index.html" class="text-gray-400 hover:text-white transition-colors font-medium">&larr; Back to Projects</a>
            <a href="https://github.com/Aiden-korbs/PathSync" target="_blank" class="text-gray-400 hover:text-white transition-colors font-medium">View Python Version</a>
        </nav>
    </header>

    <main class="container mx-auto px-6 py-12">
        <div class="lg:grid lg:grid-cols-3 lg:gap-12">
            
            <!-- Left Column: Main App -->
            <div class="lg:col-span-2 space-y-8">
                <div class="text-center">
                    <h1 class="text-4xl font-extrabold text-white">PathSync</h1>
                    <p class="text-gray-400 mt-2">Analyse Google Timeline files to see paths crossed.</p>
                </div>

                <!-- Settings Panel -->
                <div class="space-y-8 pt-8 border-t border-gray-700/50">
                    <div>
                        <h2 class="text-lg font-semibold text-gray-200 mb-4">1. Upload Timeline Files</h2>
                        <div id="file-inputs" class="space-y-3"></div>
                        <button id="add-file-btn" class="w-full mt-3 text-sm font-medium text-rose-500 hover:text-rose-400 transition">+ Add Another File</button>
                    </div>
                    
                    <div>
                        <h2 class="text-lg font-semibold text-gray-200 mb-4">2. Set Filters & Thresholds</h2>
                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                            <div>
                                <label for="start-date" class="block text-sm font-medium text-gray-400">Start Date</label>
                                <input type="date" id="start-date" class="mt-1 block w-full bg-gray-700 border-gray-600 text-white rounded-md shadow-sm focus:border-rose-500 focus:ring-rose-500 sm:text-sm p-2">
                            </div>
                            <div>
                                <label for="end-date" class="block text-sm font-medium text-gray-400">End Date</label>
                                <input type="date" id="end-date" class="mt-1 block w-full bg-gray-700 border-gray-600 text-white rounded-md shadow-sm focus:border-rose-500 focus:ring-rose-500 sm:text-sm p-2">
                            </div>
                             <div>
                                <label for="distance" class="block text-sm font-medium text-gray-400">Distance (meters)</label>
                                <input type="number" id="distance" value="100" class="mt-1 block w-full bg-gray-700 border-gray-600 text-white rounded-md shadow-sm focus:border-rose-500 focus:ring-rose-500 sm:text-sm p-2">
                            </div>
                            <div>
                                <label for="time" class="block text-sm font-medium text-gray-400">Time (minutes)</label>
                                <input type="number" id="time" value="2" class="mt-1 block w-full bg-gray-700 border-gray-600 text-white rounded-md shadow-sm focus:border-rose-500 focus:ring-rose-500 sm:text-sm p-2">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Action Button -->
                <div class="text-center pt-8 border-t border-gray-700/50">
                    <button id="run-analysis" class="w-full md:w-auto bg-rose-600 text-white font-semibold py-3 px-8 rounded-lg shadow-md hover:bg-rose-700 focus:outline-none focus:ring-2 focus:ring-rose-500 focus:ring-offset-2 focus:ring-offset-gray-900 transition disabled:bg-gray-500">
                        Run Analysis
                    </button>
                </div>

                <!-- Results Panel -->
                <div id="results-container" class="space-y-6 pt-8 border-t border-gray-700/50 hidden">
                    <h2 class="text-3xl font-bold text-center text-white">Results</h2>
                    <div id="status" class="text-center text-gray-400 p-4 bg-gray-800/50 rounded-lg border border-gray-700/80"></div>
                    <p id="summary" class="text-center font-medium text-lg"></p>
                    <div id="closest-match-card" class="bg-gray-800/50 border border-gray-700/80 rounded-xl p-6 space-y-4 hidden">
                        <h3 class="text-xl font-semibold text-rose-400">Closest Match Found</h3>
                        <div id="closest-match-details" class="space-y-3 text-sm"></div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Instructions -->
            <div class="lg:col-span-1 mt-12 lg:mt-0">
                <div class="sticky top-28">
                     <div class="bg-gray-800/50 p-4 rounded-lg border border-gray-700/80">
                        <h3 class="font-semibold text-gray-200 flex items-center mb-4">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd" />
                            </svg>
                            How to Get Your Data
                        </h3>
                        <div class="text-gray-400 text-sm space-y-4 pt-4 border-t border-gray-600">
                             <div>
                                <h4 class="font-semibold text-gray-200">Method 1: Google Takeout (Desktop)</h4>
                                <ol class="list-decimal list-inside mt-2 space-y-1">
                                    <li>Visit the <a href="https://takeout.google.com/" target="_blank" class="text-rose-500 hover:underline">Google Takeout</a> website.</li>
                                    <li>Click "Deselect all", then scroll and select "Timeline".</li>
                                    <li>Ensure the format is JSON, then "Create export".</li>
                                </ol>
                            </div>
                            <div>
                                <h4 class="font-semibold text-gray-200">Method 2: Google Maps App (Mobile)</h4>
                                <ol class="list-decimal list-inside mt-2 space-y-1">
                                    <li>Open the Google Maps app and tap your profile picture.</li>
                                    <li>Go to "Your timeline", then tap the three-dot menu (...) and select "Settings and privacy".</li>
                                    <li>Scroll to "Location settings" and tap "Download a copy of your data".</li>
                                </ol>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <script>
        const fileUploadContainer = document.getElementById('file-inputs');
        const addFileBtn = document.getElementById('add-file-btn');
        const runBtn = document.getElementById('run-analysis');
        const resultsContainer = document.getElementById('results-container');
        const statusEl = document.getElementById('status');
        const summaryEl = document.getElementById('summary');
        const closestMatchCard = document.getElementById('closest-match-card');
        const closestMatchDetails = document.getElementById('closest-match-details');
        let fileInputCounter = 0;

        function createFileInput() {
            fileInputCounter++;
            const wrapper = document.createElement('div');
            wrapper.className = 'flex items-center space-x-2';
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.id = `file-input-${fileInputCounter}`;
            input.className = 'hidden';
            
            const label = document.createElement('label');
            label.htmlFor = input.id;
            label.className = 'cursor-pointer bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium py-2 px-4 rounded-md shadow-sm transition';
            label.textContent = 'Choose File';

            const fileNameSpan = document.createElement('span');
            fileNameSpan.className = 'text-gray-400 text-sm truncate';
            fileNameSpan.textContent = 'No file chosen...';

            input.addEventListener('change', () => {
                fileNameSpan.textContent = input.files.length > 0 ? input.files[0].name : 'No file chosen...';
            });
            wrapper.append(input, label, fileNameSpan);
            fileUploadContainer.appendChild(wrapper);
        }
        
        createFileInput();
        createFileInput();
        addFileBtn.addEventListener('click', createFileInput);

        runBtn.addEventListener('click', async () => {
            runBtn.disabled = true;
            runBtn.innerHTML = `<div class="spinner w-5 h-5 border-4 rounded-full inline-block"></div> Analyzing...`;
            resultsContainer.classList.remove('hidden');
            statusEl.textContent = 'Starting analysis...';
            summaryEl.textContent = '';
            closestMatchCard.classList.add('hidden');
            
            const files = Array.from(document.querySelectorAll('input[type="file"]'))
                .filter(input => input.files.length > 0).map(input => input.files[0]);

            if (files.length < 2) {
                statusEl.textContent = 'Error: Please select at least two files.';
                runBtn.disabled = false;
                runBtn.textContent = 'Run Analysis';
                return;
            }
            
            const startDate = document.getElementById('start-date').value;
            const endDate = document.getElementById('end-date').value;

            let processedData = {};
            for (const file of files) {
                statusEl.textContent = `Parsing ${file.name}...`;
                try {
                    const jsonData = JSON.parse(await file.text());
                    const events = parseTimelineData(jsonData, startDate, endDate);
                    if (events.length > 0) {
                        processedData[file.name] = events;
                    } else {
                        statusEl.textContent += ` (Warning: No valid events found in the selected date range).`;
                    }
                } catch (error) {
                    statusEl.textContent = `Error processing ${file.name}: ${error.message}`;
                    runBtn.disabled = false;
                    runBtn.textContent = 'Run Analysis';
                    return;
                }
            }
            
            statusEl.textContent = 'Comparing timelines...';
            const fileKeys = Object.keys(processedData);
            let totalMatches = 0;
            let overallClosestMatch = null;
            
            for (let i = 0; i < fileKeys.length; i++) {
                for (let j = i + 1; j < fileKeys.length; j++) {
                    const [file1, file2] = [fileKeys[i], fileKeys[j]];
                    const [data1, data2] = [processedData[file1], processedData[file2]];
                    const distanceKm = parseFloat(document.getElementById('distance').value) / 1000;
                    const timeMins = parseInt(document.getElementById('time').value);
                    const matches = compareTimelines(data1, data2, timeMins, distanceKm);
                    if (matches.length > 0) {
                        totalMatches += matches.length;
                        const closest = findClosestMatch(matches);
                        if (!overallClosestMatch || closest.distance_km < overallClosestMatch.distance_km) {
                            overallClosestMatch = closest;
                            overallClosestMatch.files = [file1, file2];
                        }
                    }
                }
            }

            summaryEl.textContent = `Analysis complete. Found ${totalMatches} matches.`;
            if (overallClosestMatch) {
                statusEl.textContent = 'Looking up location...';
                const locationName = await getLocationName(overallClosestMatch.event1.latitude, overallClosestMatch.event1.longitude);
                displayClosestMatch(overallClosestMatch, locationName);
            } else {
                statusEl.textContent = 'No matches found within the specified thresholds.';
            }

            runBtn.disabled = false;
            runBtn.textContent = 'Run Analysis';
        });

        function displayClosestMatch(match, locationName) {
            closestMatchCard.classList.remove('hidden');
            const [file1, file2] = match.files;
            const { event1, event2, distance_km, time_difference } = match;
            const event1UTC = moment.utc(event1.timestamp).format('YYYY-MM-DD HH:mm:ss');
            const event2UTC = moment.utc(event2.timestamp).format('YYYY-MM-DD HH:mm:ss');

            closestMatchDetails.innerHTML = `
                <p><strong>Files:</strong> ${file1} & ${file2}</p>
                <p><strong>Location:</strong> ${locationName}</p>
                <p><strong>Distance:</strong> ${(distance_km * 1000).toFixed(2)} meters</p>
                <p><strong>Time Difference:</strong> ${time_difference.toFixed(2)} seconds</p>
                <div class="pt-2 mt-2 border-t border-gray-600">
                    <p class="font-semibold text-rose-400">${file1}:</p>
                    <p class="pl-2">Lat: ${event1.latitude}, Lon: ${event1.longitude}</p>
                    <p class="pl-2">Timestamp (UTC): ${event1UTC}</p>
                </div>
                <div class="pt-2 mt-2 border-t border-gray-600">
                    <p class="font-semibold text-rose-400">${file2}:</p>
                    <p class="pl-2">Lat: ${event2.latitude}, Lon: ${event2.longitude}</p>
                    <p class="pl-2">Timestamp (UTC): ${event2UTC}</p>
                </div>`;
            statusEl.textContent = 'Closest match details displayed below.';
        }
        
        function parseTimelineData(jsonData, startDateStr, endDateStr) {
            let events = [];
            const startDate = startDateStr ? new Date(startDateStr + 'T00:00:00Z').getTime() : null;
            const endDate = endDateStr ? new Date(endDateStr + 'T23:59:59Z').getTime() : null;

            const eventInRange = (timestamp) => {
                if (startDate && timestamp < startDate) return false;
                if (endDate && timestamp > endDate) return false;
                return true;
            };

            if (jsonData.semanticSegments) {
                jsonData.semanticSegments.forEach(segment => {
                    const processPoint = (time, locationString) => {
                        const timestamp = new Date(time).getTime();
                        if (eventInRange(timestamp) && typeof locationString === 'string') {
                            const coords = locationString.match(/[-+]?\d+\.\d+/g);
                            if (coords && coords.length === 2) events.push({timestamp, latitude: parseFloat(coords[0]), longitude: parseFloat(coords[1])});
                        }
                    };

                    if (segment.timelinePath) {
                        segment.timelinePath.forEach(point => processPoint(point.time, point.point));
                    } else if (segment.visit) {
                        processPoint(segment.startTime, segment.visit?.topCandidate?.placeLocation);
                    }
                });
            }
            else if (Array.isArray(jsonData)) {
                jsonData.forEach(item => {
                    const timestamp = new Date(item.startTime).getTime();
                    if (eventInRange(timestamp)) {
                         const locStr = item.visit?.topCandidate?.placeLocation;
                         if (locStr && typeof locStr === 'string') {
                            const coords = locStr.match(/[-+]?\d+\.\d+/g);
                            if (coords && coords.length === 2) events.push({timestamp, latitude: parseFloat(coords[0]), longitude: parseFloat(coords[1])});
                        }
                    }
                });
            }
            else if (jsonData.locations) {
                jsonData.locations.forEach(loc => {
                    const timestamp = new Date(loc.timestamp).getTime();
                    if (eventInRange(timestamp) && loc.latitudeE7 && loc.longitudeE7) {
                        events.push({timestamp, latitude: loc.latitudeE7 / 1e7, longitude: loc.longitudeE7 / 1e7});
                    }
                });
            }
            return events.sort((a, b) => a.timestamp - b.timestamp);
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; const toRad = x => x * Math.PI / 180;
            const dLat = toRad(lat2 - lat1); const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2)**2;
            return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
        }

        function compareTimelines(data1, data2, timeMins, distanceKm) {
            const matches = []; const timeMs = timeMins * 60 * 1000;
            let i = 0, j = 0;
            while (i < data1.length && j < data2.length) {
                const timeDiff = data1[i].timestamp - data2[j].timestamp;
                if (timeDiff > timeMs) { j++; continue; }
                if (timeDiff < -timeMs) { i++; continue; }
                let k = j;
                while (k < data2.length) {
                    const subTimeDiff = Math.abs(data1[i].timestamp - data2[k].timestamp);
                    if (subTimeDiff > timeMs) break;
                    const distance = haversineDistance(data1[i].latitude, data1[i].longitude, data2[k].latitude, data2[k].longitude);
                    if (distance <= distanceKm) matches.push({event1: data1[i], event2: data2[k], time_difference: subTimeDiff / 1000, distance_km: distance});
                    k++;
                }
                i++;
            }
            return matches;
        }

        function findClosestMatch(matches) {
            return !matches || matches.length === 0 ? null : matches.reduce((a, b) => b.distance_km < a.distance_km ? b : a);
        }
        
        async function getLocationName(lat, lon) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`);
                if (!response.ok) throw new Error(`API failed: ${response.status}`);
                const data = await response.json();
                return data.display_name || "Unknown Location";
            } catch (error) {
                console.error("Geocoding error:", error);
                return "Could not fetch location name.";
            }
        }
    </script>
</body>
</html>

